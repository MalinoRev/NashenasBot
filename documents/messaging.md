### Messaging & Media Flow (Replies) — English & فارسی

This document explains the generic pattern for sending messages and photos in the bot. It covers: context message files, handlers, routes, environment variables, step-gating, and consistent payload formats.

## English

- **Architecture**:
  - **Context messages**: Each message lives in `app/src/context/messages/...`. Files expose small functions such as `get_message(...)` or, for photos, a `get_caption(...)` function.
  - **Handlers**: Each reply has a handler in `app/src/handlers/replies/`. The handler prepares data (e.g., looks up DB user, counts referrals) and returns a structured payload to the route.
  - **Routes**: `app/src/routes/replies.py` maps stable button IDs (from `mainButtons`) to handlers, sends 1..N messages based on the handler’s payload, and may implement pre-conditions (e.g., step gating).

- **Context contracts**:
  - Text message file:
    - `get_message(...) -> str`
  - Photo caption file:
    - `get_caption(bot_username: str, referral_id: str) -> str`

- **Handler → Route payload contracts**:
  - Text only:
    - `{ "text": str }`
  - Two texts:
    - `{ "text": str, "text2": str }`
  - Photo + caption + optional text:
    - `{ "photo_path": str, "caption": str, "text": str }`

- **Media sending** (local file):
  - Use aiogram v3 `FSInputFile` in the route:
    ```python
    from aiogram.types import FSInputFile

    photo = FSInputFile(photo_path)
    await message.answer_photo(photo, caption=caption)
    ```
  - Paths are resolved to actual container paths. Our invite image is stored at:
    - `/app/src/context/resources/images/invite.jpg`
  - Handlers can build absolute paths via `pathlib.Path(__file__).resolve()` to avoid CWD issues.

- **Environment usage**:
  - `TELEGRAM_BOT_USERNAME` is read in code when generating deep links.
  - Deep-link format example: [Telegram deep-link format](https://telegram.me/ENV:USERNAME?start=UNIQUEID)

- **Gating (profile and step)**:
  - `ProfileMiddleware` blocks commands and runs an interactive flow until a `UserProfile` exists with non-null `name`, `is_female`, `age`, `state`, `city`.
  - If the profile is complete, it immediately sets `data["profile_ok"] = True` and delegates without extra work.
  - Some routes (e.g., `main:my_anon_link`) additionally check `users.step == "start"` in the DB before calling the handler. If not satisfied, they return early without sending anything.

- **Examples in this codebase**:
  - `main:my_anon_link`:
    - Messages: `context/messages/replies/myAnonLink.py` (first), `myAnonLink2.py` (second)
    - Route sends two separate messages if user step is `start`.
    - First message builds link from `TELEGRAM_BOT_USERNAME` + user’s `unique_id`.
  - `main:invite`:
    - Photo + caption + text.
    - Caption is generated by `context/messages/replies/inviteImage.py` using `bot_username` and user’s `referral_id` (`http://t.me/{username}?start=inv_{referral_id}`).
    - Referral count uses: `SELECT COUNT(*) FROM users WHERE referraled_by = current_user.id`.

- **How to add a new reply**:
  1. Create one or more message files under `context/messages/replies/`.
  2. Create a handler in `handlers/replies/` that returns one of the payload shapes above.
  3. Wire it in `routes/replies.py` to the stable ID returned by `mainButtons.resolve_id_from_text`.
  4. If needed, add route-level pre-conditions (e.g., profile complete or step check).

## فارسی

- **معماری**:
  - **پیام‌ها (context)**: هر پیام در `app/src/context/messages/...` قرار دارد و با توابع کوچکی مثل `get_message(...)` یا برای عکس‌ها `get_caption(...)` ارائه می‌شود.
  - **هندلرها**: برای هر دکمه/پاسخ، یک هندلر در `app/src/handlers/replies/` وجود دارد که داده‌ها (مانند خواندن کاربر از دیتابیس یا شمارش رفرال‌ها) را آماده کرده و یک خروجی ساختاریافته به روت برمی‌گرداند.
  - **روت‌ها**: در `app/src/routes/replies.py`، آیدی‌های پایدار دکمه‌ها (از `mainButtons`) به هندلرها نگاشت می‌شوند. روت بر اساس خروجی هندلر یک یا چند پیام ارسال می‌کند و می‌تواند شرط‌های اولیه (مانند بررسی `step`) را اعمال کند.

- **قرارداد فایل‌های پیام**:
  - متن:
    - `get_message(...) -> str`
  - کپشن عکس:
    - `get_caption(bot_username: str, referral_id: str) -> str`

- **قرارداد خروجی هندلر برای روت**:
  - فقط متن:
    - `{ "text": str }`
  - دو متن جدا:
    - `{ "text": str, "text2": str }`
  - عکس + کپشن + متن اختیاری:
    - `{ "photo_path": str, "caption": str, "text": str }`

- **ارسال مدیا (فایل لوکال)**:
  - در aiogram v3 باید از `FSInputFile` استفاده شود:
    ```python
    from aiogram.types import FSInputFile

    photo = FSInputFile(photo_path)
    await message.answer_photo(photo, caption=caption)
    ```
  - مسیر فایل باید داخل کانتینر معتبر باشد. عکس دعوت در این مسیر است:
    - `/app/src/context/resources/images/invite.jpg`
  - برای جلوگیری از مشکل مسیر کاری، می‌توان مسیر مطلق را با `pathlib.Path(__file__).resolve()` ساخت.

- **استفاده از متغیرهای محیطی**:
  - `TELEGRAM_BOT_USERNAME` برای ساخت لینک‌های دیپ استفاده می‌شود.
  - نمونه فرمت لینک: [Telegram deep-link format](https://telegram.me/ENV:USERNAME?start=UNIQUEID)

- **گیتینگ (پروفایل و step)**:
  - `ProfileMiddleware` تا زمانی‌که پروفایل کامل نشود (وجود `UserProfile` و پر بودن `name`, `is_female`, `age`, `state`, `city`) فرمان‌ها را مسدود می‌کند و جریان پرسش تعاملی را اجرا می‌کند.
  - اگر پروفایل کامل باشد، بلافاصله `data["profile_ok"] = True` تنظیم می‌شود و بدون کار اضافه به ادامه مسیر می‌رود.
  - برخی روت‌ها (مثل `main:my_anon_link`) قبل از فراخوانی هندلر، `users.step == "start"` را در دیتابیس چک می‌کنند و اگر برقرار نبود، هیچ پیامی ارسال نمی‌کنند.

- **نمونه‌ها در این پروژه**:
  - `main:my_anon_link`:
    - دو پیام جدا: `myAnonLink.py` و `myAnonLink2.py`.
    - روت فقط وقتی step کاربر `start` باشد پیام‌ها را ارسال می‌کند.
    - پیام اول از `TELEGRAM_BOT_USERNAME` و `unique_id` کاربر لینک می‌سازد.
  - `main:invite`:
    - عکس + کپشن + متن.
    - کپشن توسط `inviteImage.py` با `username` و `referral_id` ساخته می‌شود (`http://t.me/{username}?start=inv_{referral_id}`).
    - شمارش دعوت‌ها با کوئری: `COUNT(*) WHERE users.referraled_by = users.id`.

- **افزودن یک پاسخ جدید**:
  1. فایل/فایل‌های پیام را در `context/messages/replies/` بسازید.
  2. هندلر را در `handlers/replies/` ایجاد کنید و یکی از خروجی‌های قراردادی بالا را برگردانید.
  3. در `routes/replies.py` آن را به آیدی پایدار دکمه (از `mainButtons`) متصل کنید.
  4. در صورت نیاز محدودیت/شرط اولیه (مثلاً تکمیل پروفایل یا بررسی step) را در روت اعمال کنید.
